from tkinter.constants import INSERT

from flask import Flask, request, jsonify
import psycopg2
import random
import hashlib
import json
import base64
app = Flask(__name__)

points_per_level=100
connection=psycopg2.connect(
    host="localhost",
    database="MTAA",
    user="Guest",
    password="345f"
    )
cursor = connection.cursor()
def find_in_database(table, column, value):
    cursor.execute(f"""
        SELECT id 
        FROM public."{table}"
        WHERE "{column}"= %s ;
        """,(value,))
    res_id=cursor.fetchone()
    if(res_id==None):
        return None
    return res_id[0]

def get_from_database(target, table, column, value):
    cursor.execute(f"""
        SELECT "{target}" 
        FROM public."{table}"
        WHERE "{column}"= %s ;
        """,(value,))
    res_id=cursor.fetchone()
    if(res_id==None):
        return None
    return res_id[0]

def set_in_database(table, column, value, in_column, in_value):
    connection.commit()
    cursor.execute(f"""
        UPDATE public."{table}" 
        SET "{in_column}"= %s
        WHERE "{column}"= %s
        RETURNING id;
        """,(in_value, value,))
    connection.commit()
    res_id=cursor.fetchone()
    if(res_id==None):
        return None
    return res_id[0]

import re

def parse_price(price_str):
    if not price_str:
        return None
    # Remove all non-numeric characters except '.' (for decimals)
    cleaned = re.sub(r"[^\d.]", "", price_str)
    try:
        return float(cleaned) if cleaned else None
    except ValueError:
        return None

# @app.get("/store")
#def get_stores():
#    cursor.execute("""
#        SELECT table_name
#        FROM information_schema.tables
#        WHERE table_schema = 'public'  -- Change if you're using a different schema
#        ORDER BY table_name;
#    """)
#    tables=cursor.fetchall()
#    return {"stores": tables}


#@app.put("/preferences")
#def change_settings():
#    setting = request.args.get('setting')
#    val = request.args.get('val')
#    cursor.execute("""
#        SELECT table_name
#        FROM information_schema.tables
#        WHERE table_schema = 'public'  -- Change if you're using a different schema
#        ORDER BY table_name;
#    """)
#    tables=cursor.fetchall()
#    print(f"changed {setting} to {val}")
#    return {"stores": tables}

#---------------
def delete_DB():
    cursor.execute("""
        DROP TABLE public.dish;
        DROP TABLE public.special;
        DROP TABLE public.order_item;
        DROP TABLE public."order";
        DROP TABLE public.discounts;
        DROP TABLE public."user";
        DROP TABLE public.favourites;
        DROP TABLE public.delivery;
        DROP TABLE public.reservation;
        DROP TABLE public.preferences;
        """)
    connection.commit()
    print("initiazed DB")

def init_DB():
    cursor.execute("""
        -- This script was generated by the ERD tool in pgAdmin 4.
        -- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
        BEGIN;


        CREATE TABLE IF NOT EXISTS public.dish
        (
            id uuid,
            title text,
            category text,
            small_portion integer,
            medium_portion integer,
            large_portion integer,
            small_price money,
            medium_price money,
            large_price money,
            portion_unit text,
            description text,
            discount_base real,
            picture bytea,
            popularity integer,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.special
        (
            id uuid,
            dish_id uuid,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.order_item
        (
            id bigserial,
            portion integer,
            count integer,
            price money,
            dish_id uuid,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public."order"
        (
            id uuid,
            "user" uuid,
            "timestamp" timestamp with time zone,
            comment text,
            price money,
            discount_used uuid,
            items_start bigint,
            items_end bigint,
            is_paid boolean,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.discounts
        (
            id uuid,
            effectivness real,
            cost integer,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public."user"
        (
            id uuid,
            name text,
            password bytea,
            salt bytea,
            token uuid,
            discount_points integer,
            loyalty_points integer,
            level integer,
            favourite_capacity integer,
            favourite_free integer,
            pref_id uuid,
            type text,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.favourites
        (
            id uuid,
            user_id uuid,
            dish_id uuid,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.delivery
        (
            id uuid,
            order_id uuid,
            card_used boolean,
            postal_code text,
            street text,
            house_number integer,
            delivered boolean,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.reservation
        (
            id uuid,
            order_id uuid,
            date date,
            "from" time with time zone,
            until time with time zone,
            people integer,
            "table" integer,
            "QR code" bytea,
            PRIMARY KEY (id)
        );

        CREATE TABLE IF NOT EXISTS public.preferences
        (
            id uuid,
            user_id uuid,
            language text,
            darkmode boolean,
            high_contrast boolean,
            PRIMARY KEY (id)
        );
        END;
        """)
    connection.commit()
    print("initiazed DB")
    return

def clear_DB():
    cursor.execute("""
        DELETE FROM public.dish
                WHERE true;
        DELETE FROM public.special
                WHERE true;
        DELETE FROM public.order_item
                WHERE true;
        DELETE FROM public."order"
                WHERE true;
        DELETE FROM public.discounts
                WHERE true;
        DELETE FROM public."user"
                WHERE true;
        DELETE FROM public.favourites
                WHERE true;
        DELETE FROM public.delivery
                WHERE true;
        DELETE FROM public.reservation
                WHERE true;
        DELETE FROM public.preferences
                WHERE true;
        SELECT SETVAL(
            pg_get_serial_sequence('order_item', 'id'),
            (SELECT COALESCE(MAX(id), 1) FROM order_item)
        );
	""")
    connection.commit()
    print("cleared DB")
    return

def get_user_token(name):
    cursor.execute("""
        UPDATE public."user"
        SET token = gen_random_uuid()
        WHERE name= %s
        RETURNING token;
        """,(name,))
    res = cursor.fetchone()
    connection.commit()
    if(res==None):
        return None
    return res[0]

def get_id(token):
    try:
        cursor.execute("""
            SELECT id
            FROM public."user"
            WHERE token = %s ;
            """,(token,))
        if(cursor.description is None):
            return None
        res1 = cursor.fetchone()
        if(res1==None):
            return None
        return res1[0]
    except:
        return None

def invalidate_user_token(token):
    cursor.execute("""
        UPDATE public."user"
        SET token = null
        WHERE token= %s
        RETURNING token;
        """,(token,))
    res = cursor.fetchone()
    connection.commit()
    if(res==None):
        return None
    return res[0]

def register_user(name, password, user_role="registered"):
    name=str(name)
    password=str(password)
    
    salt=random.randbytes(8)
    sha256=hashlib.sha256()
    sha256.update(password.encode())
    sha256.update(salt)
    pass_hash=sha256.hexdigest().encode()
    print("adding: ",name)
    print(salt)
    print(pass_hash)
    print("------")

    cursor.execute("""
        SELECT password, salt 
        FROM public."user"
        WHERE name= %s ;
        """,(name,))
    res=cursor.fetchone()
    if(res!=None):
        return False
    
    try:
        cursor.execute("""
        INSERT INTO public."user"(
            id, name, password, salt, 
            discount_points, loyalty_points, level, 
            favourite_capacity, favourite_free, pref_id,
            type)
            VALUES (
            gen_random_uuid(), %s, %s, %s, 
            0, 0, 0, 
            0, 0, null,
            %s );
            """, (name, pass_hash, salt, user_role))
        connection.commit()
    except:
        return None
    return True

def add_points_to(discount, loyalty, name):
    cursor.execute("""
        UPDATE public."user"
        SET discount_points = discount_points + %s,
        loyalty_points = loyalty_points + %s
        WHERE name = %s;
        """,(discount, loyalty,name))
    connection.commit()

def add_points_to_id(discount, loyalty, user_id):
    cursor.execute("""
        UPDATE public."user"
        SET discount_points = discount_points + %s,
        loyalty_points = loyalty_points + %s
        WHERE id = %s;
        """, (discount, loyalty, user_id))
    connection.commit()

def level_up(user_id):
    connection.commit()
    old_points=get_from_database("loyalty_points", "user", "id", user_id)
    if(old_points<points_per_level):
        return False
    set_in_database("user", "id", user_id, "loyalty_points", old_points-points_per_level)

    old_lvl=get_from_database("level", "user", "id", user_id)
    set_in_database("user", "id", user_id, "level", old_lvl+1)
    recalculate_favourite_cap(user_id)
    return True


def recalculate_favourite_cap(user_id):
    old_cap = get_from_database("favourite_capacity", "user", "id", user_id)
    connection.commit()
    cursor.execute("""
        UPDATE public."user"
        SET favourite_capacity = 2 * level
        WHERE id = %s ;
        """,(user_id,))
    connection.commit()

    new_cap = get_from_database("favourite_capacity", "user", "id", user_id)
    diff=new_cap-old_cap
    if(diff==0):
        return
    fav_free = get_from_database("favourite_free", "user", "id", user_id)
    set_in_database("user", "id", user_id, "favourite_free", fav_free+diff)

def login(name, password):
    name=str(name)
    password=str(password)
    
    cursor.execute("""
        SELECT password, salt 
        FROM public."user"
        WHERE name= %s ;
        """,(name,))
    password_salt=cursor.fetchone()
    if(password_salt == None):
        return False

    user_salt=password_salt[1].tobytes()
    sha256=hashlib.sha256()
    sha256.update(password.encode())
    sha256.update(user_salt)
    pass_hash=sha256.hexdigest().encode()
    
    return password_salt[0].tobytes() == pass_hash

@app.get("/sensitive_info")
def get_sensitive_info():
    token = request.args.get("token")
    if not token:
        return jsonify({'message': "missing token"}), 401

    user_id = get_id(token)
    if user_id is None:
        return jsonify({'message': "no session with this user"}), 401

    cursor.execute('SELECT type FROM "user" WHERE id = %s', (user_id,))
    user = cursor.fetchone()
    if not user:
        return jsonify({'message': "user not found"}), 404

    user_type = user[0]
    return jsonify({'user_type': user_type}), 200


@app.put("/change_password")
def change_password():
    token = request.args.get("token")
    user_type = request.args.get("user_type", "anonymous")
    old_password = request.args.get("old_password")
    new_password = request.args.get("new_password")

    if not token or not new_password:
        return jsonify({'message': "missing required fields"}), 401

    user_id = get_id(token)
    if user_id is None:
        return jsonify({'message': "no session with this user"}), 401

    cursor.execute('SELECT name FROM "user" WHERE id = %s', (user_id,))
    name = cursor.fetchone()[0]
    if not name:
        return jsonify({'message': "invalid user"}), 401

    name = name[0]

    if user_type != "admin":
        if not old_password:
            return jsonify({'message': "old password is required"}), 401

        print("trying",name, old_password)
        if not login(name, old_password):
            return jsonify({'message': "incorrect old password"}), 403

    user_salt = random.randbytes(8)
    sha256 = hashlib.sha256()
    sha256.update(new_password.encode())
    sha256.update(user_salt)
    pass_hash = sha256.hexdigest().encode()

    try:
        cursor.execute("""
            UPDATE "user"
            SET password = %s, salt = %s
            WHERE id = %s;
        """, (pass_hash, user_salt, user_id))
        connection.commit()
    except Exception as e:
        print("Error during update:", e)
        return jsonify({'message': "something went wrong during password update"}), 500

    return jsonify({'message': "password changed successfully"}), 200

@app.get("/account_info")	#user + preferences
def account_info():
    token = request.args.get('token')
    if (token == None):
        return  jsonify({'message': "missing token"}), 401

    user_id = get_id(token)
    if (user_id == None):
        return jsonify({'message': "no session with this user"}), 401

    pref = get_from_database("pref_id", "user", "id", user_id)
    # if (pref == None):                                        #do not use
    #     return jsonify({'message': "no preference"}), 404

    cursor.execute("""
            SELECT "name", discount_points, loyalty_points,
            level, favourite_capacity, favourite_free,
             language, darkmode, high_contrast
            FROM public."user" AS u LEFT JOIN public.preferences AS p
            ON u.id = p.user_id
            WHERE u.id = %s
            """,(user_id,))
    result = cursor.fetchone()

    if not result:
        return jsonify({'message': "User not found"}), 404

    return jsonify({
        'account_info': {
            'name': result[0],
            'discount_points': result[1],
            'loyalty_points': result[2],
            'level': result[3],
            'favourite_capacity': result[4],
            'favourite_free': result[5],
            'language': result[6],
            'darkmode': result[7],
            'high_contrast': result[8],
        }
    }), 200



@app.delete("/remove_user")
def remove_user():
    name = request.args.get("name")
    password = request.args.get("password")
    user_id = find_in_database("user", "name", name)
    # print("user: ", name, user_id, type(name), type(user_id))

    if not user_id:
        return "invalid user"
    if not login(name, password):
        return "invalid password"

    order_id = get_from_database("id", "order", "user", user_id)
    if order_id:
        return "unable to delete user during order fulfilment"

    if get_from_database("id", "favourites", "user", user_id):
        try:
            cursor.execute("""
            DELETE FROM favourites
            WHERE "user" = %s; 
            """, (user_id,))
            connection.commit()
        except:
            return "something went wrong while deleting favourites associated with user"

    if get_from_database("id", "preferences", "user", user_id):
        try:
            cursor.execute("""
            DELETE FROM preferences
            WHERE "user" = %s; 
            """, (user_id,))
            connection.commit()
        except:
            return "something went wrong while deleting preferences associated with user"

    try:
        cursor.execute("""
        DELETE FROM public."user"
        WHERE name = %s; 
        """, (name,))
        connection.commit()
    except:
        return "something went wrong while removing user"

    return "user removed successfully"

@app.post("/change_preferences")
def change_preferences():
    data = request.get_json()
    token = data.get("token")
    language = data.get("language")
    darkmode = data.get("darkmode")
    high_contrast = data.get("high_contrast")

    if not data or 'token' not in data:
        return jsonify({'message': 'Missing token'}), 400

    user_id = get_id(data['token'])
    if user_id is None:
        return jsonify({'message': 'Invalid or expired session'}), 401

    # Check if preferences exist
    cursor.execute("""SELECT 1 FROM preferences WHERE user_id = %s""", (user_id,))
    if cursor.fetchone() is None:
        # Insert default preferences (or use data from request if preferred)
        try:
            cursor.execute("""
                INSERT INTO preferences (id, user_id, language, darkmode, high_contrast)
                VALUES (gen_random_uuid(), %s, %s, %s, %s)
            """, (user_id, language or 'ENG', darkmode or False, high_contrast or False))
            connection.commit()
        except Exception as e:
            print(e)
            return jsonify({'message': 'Error inserting preferences'}), 500

    # Update only provided fields
    if language is not None:
        cursor.execute("""UPDATE preferences SET language = %s WHERE user_id = %s""", (language, user_id))
    if darkmode is not None:
        cursor.execute("""UPDATE preferences SET darkmode = %s WHERE user_id = %s""", (darkmode, user_id))
    if high_contrast is not None:
        cursor.execute("""UPDATE preferences SET high_contrast = %s WHERE user_id = %s""", (high_contrast, user_id))

    pref = get_from_database("id", "preferences", "user_id", user_id)

    cursor.execute("""UPDATE "user" SET pref_id = %s WHERE id = %s""", (pref, user_id))

    connection.commit()

    return jsonify({'success': True}), 200


@app.post("/favourite")
def add_favourite():
    token=request.args.get('token')
    if(token==None):
        return {'message':"missing token"},401
    
    user_id=get_id(token)
    if(user_id==None):
        return {'message':"no session with this user"},401
    
    dish_name = request.args.get("dish_name")
    dish_id = find_in_database("dish", "title", dish_name)
    if not (dish_id):
        return {'message':"dish does not exist"},404
 
    cursor.execute("""
    SELECT dish_id 
    FROM favourites
    WHERE user_id = %s and dish_id = %s; 
    """, (user_id, dish_id))
    check=cursor.fetchone()

    if check:
        return {'message':"dish is already favourite"},409 
 
    fav_free = get_from_database("favourite_free", "user", "id", user_id)
    if fav_free == 0:
        return {'message':"no space left, sorry :c"},400
 
    try:
        cursor.execute("""
        INSERT INTO public.favourites(
        id, user_id, dish_id)
        VALUES (gen_random_uuid(), %s, %s);
        """, (user_id, dish_id))
        connection.commit()
    except:
        return {'message':"something went wrong during add favourite"},500 
 
    set_in_database("user", "id", user_id, "favourite_free", fav_free-1)
    return {'message':"added favourite successfully"},200


@app.delete("/favourite")
def remove_favourite():
    token=request.args.get('token')
    if(token==None):
        return {'message':"missing token"},401
    
    user_id=get_id(token)
    if(user_id==None):
        return {'message':"no session with this user"},401
    
    dish_name = request.args.get("dish_name")
    dish_id = find_in_database("dish", "title", dish_name)
    if not (dish_id):
        return {'message':"dish does not exist"},404

    cursor.execute("""
        SELECT dish_id 
        FROM favourites
        WHERE user_id = %s and dish_id = %s; 
        """, (user_id, dish_id))
    check = cursor.fetchone()

    if not check:
        return {'message':"dish is not in favourites"},404

    try:
        cursor.execute("""
        DELETE FROM favourites
        WHERE user_id = %s and dish_id = %s; """,(user_id, dish_id))
        connection.commit()
    except:
        return {'message':"something went wrong during remove favourite"},500 

    fav_free = get_from_database("favourite_free", "user", "id", user_id)
    set_in_database("user", "id", user_id, "favourite_free", fav_free+1)
    return {'message':"removed favourite successfully"},200 

@app.get("/favourite")
def get_favourites():
    token=request.args.get('token')
    if(token==None):
        return {'message':"missing token"},401
    
    user_id=get_id(token)
    if(user_id==None):
        return {'message':"no session with this user"},401

    connection.commit()
    cursor.execute("""
            SELECT 
                d.id, title, category, 
                small_portion, medium_portion, large_portion, 
                small_price, medium_price, large_price, portion_unit,
                description, discount_base
            FROM public.dish AS d JOIN public.favourites AS f
            ON d.id = f.dish_id
            WHERE f.user_id = %s
            """,(user_id,))
    dishes=cursor.fetchall()
    connection.commit()

    try:
        formatted_dishes=[
            {'id':dish[0], 'title':dish[1], 'category':dish[2], 
                'small_portion':dish[3], 'medium_portion':dish[4],
                'large_portion':dish[5],'small_price':dish[6],
                'medium_price':dish[7], 'large_price':dish[8], 'portion_unit':dish[9],
                'description':dish[10], 'discount_base':dish[11]}
            for dish in dishes
        ]
    except:
        print("error somehow with this: ",dishes)
        formatted_dishes=[]

    return {'message':"""returning favourite dishes""",
            'dishes':formatted_dishes},200

@app.get("/reservation")	#user + reservation
def account_reservations():
    token = request.args.get('token')
    if (token == None):
        return jsonify({'message': "missing token"}), 401

    user_id = get_id(token)
    if (user_id == None):
        return jsonify({'message': "no session with this user"}), 401

    order = get_from_database("id", "order", "user", user_id)
    if (order == None):
        return jsonify({'message': "no order"}), 404

    # reservation = get_from_database("id", "reservation", "order_id", order)
    # if (reservation == None):
    #     return jsonify({'message': "no reservation"}), 404

    cursor.execute("""
            SELECT r.id, date, "from", until, people, "table"
            FROM public."user" AS u JOIN public."order" AS o
            ON u.id = o."user"
            JOIN public.reservation AS r
            ON o.id = r.order_id
            WHERE u.id = %s
            ORDER BY date DESC, "from" DESC
            """,(user_id,))
    result = cursor.fetchall()
    print(result)
    reservations = [
        {
            'id': row[0],
            'date': str(row[1]),
            'from': str(row[2]),
            'until': str(row[3]),
            'people': row[4],
            'table': row[5],
        }
        for row in result
    ]
    print(reservations)
    return jsonify({'reservations': reservations}), 200

@app.delete("/cancel_reservation")
def cancel_reservation():
    name = request.args.get("name")

    user_id = find_in_database("user", "name", name)
    if not user_id:
        return "invalid user"

    
    print("AA")
    order_id = get_from_database("id", "order", "user", user_id)
    print(user_id, ":", order_id)

    if not order_id:
        return "the order does not exist"

    try:
        cursor.execute("""
        DELETE FROM reservation
        WHERE order_id = %s; """, (order_id,))
        connection.commit()
    except:
        return "something went wrong during reservation cancel"

    try:
        cursor.execute("""
        DELETE FROM public."order"
        WHERE id = %s; """, (order_id,))
        connection.commit()
    except:
        return "reservation cancelled, but no order associated"

    return "reservation cancelled successfully"


def add_discount_option(effectivness, cost):
    try:
        cursor.execute("""
            INSERT INTO public.discounts(
            id, effectivness, cost)
            VALUES (gen_random_uuid(), %s, %s);
            """, (effectivness, cost))
        connection.commit()
    except:
        return False
    return True

def add_dish_to_menu(title,category, small,medium,large,unit,description,disc_base,pic):
    if(small==None):
        small=(None,None)
    if(medium==None):
        medium=(None,None)
    if(large==None):
        large=(None,None)
    try:
        cursor.execute("""
            INSERT INTO public.dish(
            id, title, category,
            small_portion, medium_portion, large_portion, 
            small_price, medium_price, large_price, portion_unit, 
            description, discount_base, picture)
            VALUES (gen_random_uuid(), %s, %s,
            %s, %s, %s, 
            %s, %s, %s, %s,
            %s, %s, %s);
            """,(title,category,
                 small[0],medium[0],large[0],
                 small[1],medium[1],large[1],unit,
                 description, disc_base, pic))
        connection.commit()
    except:
        return False
    return True

def set_today_special(dish_name):
    cursor.execute("""
        SELECT id 
        FROM public.dish
        WHERE title= %s ;
        """,(dish_name,))
    dish_id=cursor.fetchone()
    if(dish_id==None):
        return False
    dish_id=dish_id[0]

    if(True):
        cursor.execute("""
            INSERT INTO public.special(
            id,dish_id)
            VALUES (gen_random_uuid(), %s);
            """, (dish_id,))
        connection.commit()
    else:
        return False
    return True

def add_order(user_id, items, comment, discount):
    print(f"adding order by {user_id} with discount {discount}")
    print("items:",items)
    print("comment:",comment)
    ids=[]
    if(not items):
        order_id=None
        try:
            cursor.execute("""
                INSERT INTO public."order"(
                id, "user", "timestamp", comment,
                price, discount_used, items_start, items_end)
                VALUES (gen_random_uuid(), %s, NOW(), %s,
                %s, %s, %s, %s) RETURNING id;
                """,(user_id, comment,0.0,
                discount, None, None))
            order_id=cursor.fetchone()[0]
            connection.commit()
            return order_id
        except:
            connection.commit()
            return None

    #get discount effect
    try:
        disc_cost=get_from_database("cost", "discounts", "id",discount)
    except:
        connection.commit()
        return ("invalid discount format",)
    if(disc_cost != None):
        user_disc_points=get_from_database("discount_points", "user", "id",user_id)
        if(user_disc_points<disc_cost):
            return (f"not enough discount points {user_disc_points}<{disc_cost}",)
        disc_effect=get_from_database("effectivness", "discounts", "id",discount)
    elif(discount != None):
        return ("invalid discount",)
    else:
        disc_effect=0.0
        disc_cost=0

    #add order items
    try:
        for item in items:
            cursor.execute("""
                INSERT INTO public.order_item(
                id, portion, count, price, dish_id)
                VALUES (DEFAULT,%s,%s,0,%s)
                RETURNING id;
                """,(item[1],item[2],item[0],))
            ids.append(cursor.fetchone()[0])
    except:
        print("order item serial ID overflow")
        return None
    connection.commit()
    order_start=min(ids)
    order_end=max(ids)

    #calculate prices
    try:
        cursor.execute("""
            UPDATE public.order_item AS items
            SET price = (CASE
            WHEN portion=1 THEN dish.small_price
            WHEN portion=2 THEN dish.medium_price
            ELSE dish.large_price END)*count
            FROM public.dish AS dish WHERE dish.id=dish_id
            AND %s <= items.id and items.id <= %s;
            """,(order_start, order_end,))
        connection.commit()
    except:
        print("failed to calculate price of order items")
        return None
    connection.commit()

    #check for nonexistant portion size
    cursor.execute("""
        SELECT title, (CASE
        WHEN portion=1 THEN 'small'
        WHEN portion=2 THEN 'medium'
        ELSE 'large' END)
        FROM public.dish AS dish
        JOIN public.order_item AS items ON dish.id=dish_id
        WHERE %s <= items.id and items.id <= %s and items.price IS NULL;
        """, (order_start, order_end,))
    res=cursor.fetchall()
    if(res):
        return res

    #adjust prices for favourite foods
    cursor.execute("""
        UPDATE public.order_item AS items
        SET price = price * (1-discount_base)
        FROM public.favourites AS fav
        JOIN public.dish as dish
        ON fav.user_id=%s AND fav.dish_id=dish.id
        WHERE fav.dish_id=items.dish_id
        AND %s <= items.id and items.id <= %s;
        """, (user_id, order_start, order_end,))
    connection.commit()

    #calculate total price including discount
    cursor.execute("""
        SELECT SUM(price)*(1.0-%s)
        FROM public.order_item
        WHERE %s <= id and id <= %s;
        """, (disc_effect, order_start, order_end,))
    total_price=cursor.fetchone()[0]
    print(total_price)

    #add order
    order_id=None
    try:
        cursor.execute("""
            INSERT INTO public."order"(
            id, "user", "timestamp", comment,
            price, discount_used, items_start, items_end)
            VALUES (gen_random_uuid(), %s, NOW(), %s,
            %s, %s, %s, %s) RETURNING id;
            """,(user_id, comment,total_price,
            discount, order_start, order_end))
        order_id=cursor.fetchone()[0]
        connection.commit()
    except:
        connection.commit()
        return None

    #subtract discount points
    cursor.execute("""
        UPDATE public."user"
        SET discount_points = discount_points - %s
        WHERE id = %s;
        """,(disc_cost,user_id))
    connection.commit()
    print(ids)
    return order_id

def bind_image_to_dish(image, dish):
    f = open(image,"br")
    dish_id = find_in_database("dish","title",dish)
    if(dish_id==None):
        print("dish not found during image binding")
        return
    set_in_database("dish","id",dish_id,"picture",f.read())
    connection.commit()
    #print(f.read())

def bind_data_to_dish(data, dish):
    dish_id = find_in_database("dish","title",dish)
    if(dish_id==None):
        print("dish not found during image binding")
        return
    set_in_database("dish","id",dish_id,"picture",data)
    connection.commit()

#------------
clear_DB()
delete_DB()
init_DB()

register_user("Peter", 123)
add_points_to(140, 75, "Peter")
register_user("Karol", "456")
register_user("anon", "anon","anonymous")
register_user("admin", "admin","admin")
print("trying logging in")
print(login("aa",56))
print(login("Peter",56))
print(login("Peter",123))
print("making discounts")
print(add_discount_option(0.10, 100))
print(add_discount_option(0.15, 140))
print(add_discount_option(0.20, 175))
print("adding dishes")
print(add_dish_to_menu("vodka","drink",(300,2.65),(540,3.79),None,
                       "ml","velmi dobra",0.2,None))
print(add_dish_to_menu("zemiaky","hlavne",(140,1.05),(240,1.79),(360,2.50),
                       "g","chutne",0.1,None))
print(add_dish_to_menu("vyvar","polievka",(200,1.30),(300,1.69),None,
                       "g","domaca",0.1,None))
print("setting special")
set_today_special("vodka")
bind_image_to_dish("DB.png","zemiaky")
bind_image_to_dish("meme.png","vodka")



#----------
@app.post("/login")
def try_to_login():
    name = request.args.get('name')
    password = request.args.get('password')

    token = get_user_token(name)
    if(login(name,password)):
        return {'message':"correct password",
                'token':token,
                'type':get_from_database('type', 'user', 'token',token)},200
    else:
        return {'message':"wrong password or username"},401

@app.post("/register")
def try_to_register():
    name = request.args.get('name')
    password = request.args.get('password')
    res = register_user(name,password)
    
    if(res==None):
        res = register_user(name,password)
    if(res == True):
        return {'message':"registration successful",
                'token': get_user_token(name)}, 201
    elif(res==None):
        return {'message':"something went wrong, try again"},500
    else:
        return {'message':"username already taken"},409

@app.post("/logout")
def try_to_logout():
    token = request.args.get('token')
    if (token == None):
        return {'message': "missing token"}, 401
    
    invalidate_user_token(token)
    return {'message': "token invalidated"}, 200



@app.post("/delivery")
def delivery():
    token = request.args.get('token')
    if (token == None):
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if (user_id == None):
        return {'message': "no session with this user"}, 401

    try:
        data=json.loads(request.data)
        data=data["body"]
    except:
        return {'message':"wrong format"}, 400

    try:
        address=[0,0,0]
        json_address=data["address"]
        address[0]=str(json_address["postal code"])
        address[1]=str(json_address["street"])
        address[2]=int(json_address["number"])
    except:
        return {'message':"wrong address fromat"}, 400

    try:
        discount=data["discount used"]
    except:
        discount=None

    try:
        comment=data["comment"]
    except:
        comment=""
    
    try:
        json_items=data["items"]
    except:
        return {'message':"no items"}, 400

    #get order items
    try:
        items=[0]*len(json_items)
        for i in range(len(json_items)):
            items[i]=[0,0,0]
            
            items[i][0]=find_in_database("dish","title",json_items[i]["name"])
            if(items[i][0]==None):
                return {'message':
                        f'nonexistant food: {json_items[i]["name"]}'}, 404

            items[i][1]=json_items[i]["size"]
            if(items[i][1]=="small"):
                items[i][1]=1
            elif(items[i][1]=="medium"):
                items[i][1]=2
            elif(items[i][1]=="large"):
                items[i][1]=3
            else:
                return {'message':f"invalid portion size: {items[i][1]}"}, 400

            
            items[i][2]=int(json_items[i]["count"])
            if(items[i][2]<1):
                return {'message':
                    f"""wrong food count {json_items[i]["name"]}:
                    {json_items[i]["count"]}"""}, 400
    except:
        return {'message':"invalid food item format"}, 400

    order_id=add_order(user_id, items, comment, discount)
    if(order_id==None):
        return {'message':"order failed"}, 500

    if(order_id.__class__ == list):
        return {'message':f"nonexistant food portion size {order_id}"},404

    if(order_id.__class__ == tuple):
        return {'message':order_id[0]},400

    #add delivery
    cursor.execute("""
        INSERT INTO public.delivery(
        id, order_id, postal_code,
        street, house_number, delivered)
        VALUES (gen_random_uuid(), %s, %s,
        %s, %s, false);
        """, (order_id, address[0],address[1],address[2]))
    connection.commit()
    return {'message':"delivery order successful",
            'order id':order_id,
            'price': get_from_database('price','order','id',order_id)
            },200

from datetime import datetime, timedelta
@app.post("/reservation")
def make_reservation():
    token = request.args.get('token')
    if (token == None):
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if (user_id == None):
        return {'message': "no session with this user"}, 401

    try:
        data=json.loads(request.data)
        data=data["body"]
    except:
        return {'message': "wrong format"}, 400

    try:
        dtime=[0,0,0]
        people=int(data["people"])
        json_dtime=data["datetime"]
        dtime[0]=datetime.strptime(str(json_dtime["date"]),"%d.%m.%Y")
        dtime[1]=datetime.strptime(str(json_dtime["from"]),"%H:%M").time()
        dtime[2]=datetime.strptime(str(json_dtime["until"]),"%H:%M").time()
        timestring=str(dtime[0].date())+' '+str(dtime[1])
        from_dtime=datetime.strptime(timestring,"%Y-%m-%d %H:%M:%S")
    except:
        return {'message': "wrong time format"}, 400

    if(dtime[1]>dtime[2]):
        return {'message': "departure needs to happen after arrival"}, 400
    valid_frod_dtime=datetime.now() + timedelta(hours=1)
    if(from_dtime<valid_frod_dtime):
        return {'message': f"""reservation can be at earliest
    {valid_frod_dtime.replace(second=0, microsecond=0)}"""}, 400
        

    try:
        discount=data["discount used"]
    except:
        discount=None

    try:
        comment=data["comment"]
    except:
        comment=""

    food_ordered = True
    try:
        json_items=data["items"]
    except:
        food_ordered = False

    #get order items
    order_id=None
    if(food_ordered):
        try:
            items=[0]*len(json_items)
            for i in range(len(json_items)):
                items[i]=[0,0,0]
                
                items[i][0]=find_in_database("dish","title",json_items[i]["name"])
                if(items[i][0]==None):
                    return {'message':
                            f'nonexistant food: {json_items[i]["name"]}'
                            },404

                items[i][1]=json_items[i]["size"]
                if(items[i][1]=="small"):
                    items[i][1]=1
                elif(items[i][1]=="medium"):
                    items[i][1]=2
                elif(items[i][1]=="large"):
                    items[i][1]=3
                else:
                    return {'message':
                            f"invalid portion size: {items[i][1]}"
                            },400

                
                items[i][2]=int(json_items[i]["count"])
                if(items[i][2]<1):
                    return {'message':f'wrong food count {json_items[i]["name"]}:{json_items[i]["count"]}'},400
        except:
            return {'message':"invalid food item format"},400

        order_id=add_order(user_id, items, comment, discount)
        if(order_id==None):
            return {'message': "order failed"}, 400

        if(order_id.__class__ == list):
            return {'message':
                    f"nonexistant food portion size {order_id}"
                    },404

        if(order_id.__class__ == tuple):
            return {'message': order_id[0]}, 400
    else:
        cursor.execute("""
            INSERT INTO public."order"(
            id, "user", "timestamp", comment,
            price, discount_used, items_start, items_end)
            VALUES (gen_random_uuid(), %s, NOW(), %s,
            0.00, NULL, NULL, NULL) RETURNING id;
            """, (user_id, comment),)
        order_id=cursor.fetchone()[0]
        connection.commit()

    cursor.execute("""
        UPDATE public."order"
        SET price = price + '$1.50'
        WHERE id = %s;
        """, (order_id,))
    connection.commit()
        

   #add reservation
    chosen_table=random.randint(0, 10)
    cursor.execute("""
        INSERT INTO public.reservation(
        id, order_id, date, "from",
        until, people, "table", "QR code")
        VALUES (gen_random_uuid(), %s, %s, %s,
        %s, %s, %s, NULL) RETURNING id;
        """, (order_id, dtime[0], dtime[1], dtime[2], people, chosen_table))
    connection.commit()
    res_id=cursor.fetchone()
    if(res_id!=None):
        res_id=res_id[0]

    #emit to socket
    data2 = {
        'id': res_id,
        'date': str(dtime[0].date()),
        'from': str(dtime[1]),
        'until': str(dtime[2]),
        'people': people,
        'table': chosen_table,
        'QR_code': None,
        }
    socketio.emit('reservation_update', data2)
	
    return {'message': "reservation order successful",
            'order id':order_id,
            'price': get_from_database('price','order','id',order_id)
            },200


@app.get("/discounts")
def available_discounts():
    token = request.args.get('token')
    if (token == None):
        return {'message': "missing token"}, 401

    try:
        cursor.execute("""
            SELECT id, effectivness, cost FROM discounts;
            """)
        res = cursor.fetchall()
    except:
        return {'message': "failed"}, 500

    try:
        formatted_discounts=[
            {'id':disc[0], 'effectivness':disc[1], 'cost':disc[2]}
            for disc in res
        ]
    except:
        formatted_discounts=[]
    return {'message': "listing available discounts",
            'discounts':formatted_discounts,
            'owned DPs':get_from_database('discount_points', 'user', 'token',token)
            }, 200

from flask import send_file
from flask import Response
from io import BytesIO
@app.get("/dish/picture")
def get_dish_pic():
    dish_name = request.args.get('dish')
    pic=get_from_database("picture", "dish","title",dish_name)
    if(pic==None):
        return "dish pic not found", 404
    pic=pic.tobytes()
    
    return send_file(BytesIO(pic),
                     mimetype='image/jpg',
                     as_attachment=False,
                     download_name='image.jpg')
    
@app.post("/dish/picture")
def insert_dish_pic():
    dish_name = request.args.get('dish')

    
    data=request.get_data()
    #print(data)
    file = request.files['image']
    bind_data_to_dish(file.read(),dish_name)
    #byte1 = file.read()
    #print(byte1)
    return "yay"

@app.get("/dish")
def get_filtered_dishes():
    
    token=request.args.get('token')
    if(token==None):
        return {'message':"missing token"},401
    
    user_id=get_id(token)
    if(user_id==None):
        return {'message':"no session with this user"},401

    limit = 10
    offset=request.args.get('offset')
    if(offset==None):
        offset=0
    else:
        try:
            offset=int(offset)
        except:
            return {'message':"invalid input"},400
    
    phrase=request.args.get('phrase')
    if(phrase==None):
        phrase=""
    category=request.args.get('category')
        
    phrase="_*"+phrase+"_*"
    if(category==None):
        cursor.execute("""
            SELECT 
                id, title, category, 
                small_portion, medium_portion, large_portion, 
                small_price, medium_price, large_price, portion_unit,
                description, discount_base
            FROM
            (SELECT id, title, category, 
                small_portion, medium_portion, large_portion, 
                small_price, medium_price, large_price, portion_unit,
                description, discount_base, 
                ROW_NUMBER() OVER(ORDER BY popularity DESC) AS ind
                FROM public.dish
            WHERE title ~* %s) 

            WHERE ind> %s AND ind<= %s
            ORDER BY ind asc;
            """,(phrase,offset,offset+limit))
    else:
        cursor.execute("""
            SELECT 
                id, title, category, 
                small_portion, medium_portion, large_portion, 
                small_price, medium_price, large_price, portion_unit,
                description, discount_base
            FROM
            (SELECT id, title, category, 
                small_portion, medium_portion, large_portion, 
                small_price, medium_price, large_price, portion_unit,
                description, discount_base, 
                ROW_NUMBER() OVER(ORDER BY popularity DESC) AS ind
                FROM public.dish
            WHERE title ~* %s AND category = %s) 

            WHERE ind> %s AND ind<= %s
            ORDER BY ind asc;
            """,(phrase,category,offset,offset+limit))

    dishes=cursor.fetchall()

    formatted_dishes=[
        {'id':dish[0], 'title':dish[1], 'category':dish[2], 
            'small_size':dish[3], 'medium_size':dish[4],
            'large_size':dish[5],'small_price':dish[6],
            'medium_price':dish[7], 'large_price':dish[8], 'unit':dish[9],
            'description':dish[10], 'discount_base':dish[11]}
        for dish in dishes
    ]

    return {'message':f"""returning valid dishes, from {offset} to {offset+limit}""",
            'dishes':formatted_dishes},200


@app.post("/pay")
def pay_for_order():
    token = request.args.get('token')
    if (token == None):
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if (user_id == None):
        return {'message': "no session with this user"}, 401
    user_type = get_from_database("type", "user", "id", user_id)

    order_id = request.args.get('order_id')
    if (find_in_database("order", "id", order_id) == None):
        return {'message': "no such order"}, 404

    reservation_id = find_in_database("reservation", "order_id", order_id)
    delivery_id = find_in_database("delivery", "order_id", order_id)
    if (bool(reservation_id == None) == bool(delivery_id == None)):
        return {'message': "order not tied to exact resrvation/delivery"}, 409

    try:
        data = json.loads(request.data)
        data = data["body"]
    except:
        return {'message': "wrong format"}, 400

    pay_on_delivery = request.args.get('pay_on_delivery')
    if (pay_on_delivery == None):
        pay_on_delivery = False
    else:
        try:
            pay_on_delivery = (pay_on_delivery == "true")
        except:
            return {'message': "wrong pay_on_delivery format"}, 400

    # paying API here
    has_paid = not pay_on_delivery
    print(order_id, has_paid, pay_on_delivery)
    if (has_paid):
        print("asdas")
        # set true to paid
        connection.commit
        cursor.execute("""
            update "order" set is_paid = true  where "id" = %s ;
            """, (order_id,))
        connection.commit()
    elif (pay_on_delivery and user_type != "anonymous" and delivery_id != None):
        # set card used false
        cursor.execute("""
            update "order" set is_paid = false  where "id" = %s ;
            """, (order_id,))
        connection.commit()
    else:
        return {'message': "failed payment"}, 400

    # set card used
    if (delivery_id != None):
        set_in_database("delivery", "id", delivery_id, "card_used", not pay_on_delivery)

    # update the account loyalty levels if not anonymous
    points = get_from_database("price", "order", "id", order_id)
    points = int(float(points[1:])) + 5;
    points = int(points / 2)
    disc_points = int(points / 5)

    # update the account loyalty levels if not anonymous
    add_points_to_id(disc_points, points, user_id)
    leveled_up = level_up(user_id)

    return {'message': "successful payment",
            'leveled_up': leveled_up,
            'obtained_points': points,
            'disc_points': disc_points
            }, 200


@app.get("/dish_full_info")
def get_full_dish_info():
    token = request.args.get('token')
    dish_id = request.args.get('dish_id')
    if token is None:
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if user_id is None:
        return {'message': "no session with this user"}, 401

    cursor.execute("""
        SELECT id, title, category, 
               small_portion, medium_portion, large_portion, 
               small_price, medium_price, large_price, portion_unit,
               description, discount_base, picture
        FROM public.dish
        WHERE id = %s;
    """, (dish_id,))

    dishes = cursor.fetchall()
    if not dishes:
        return {'message': 'Dish not found'}, 404

    # Debug: column count
    print("Columns returned:", len(dishes[0]))  # Should be 13

    # Extract the first (and only) dish from the result
    dish = dishes[0]

    # Handle picture
    picture_bytes = bytes(dish[12]) if dish[12] is not None else None
    base64_pic = base64.b64encode(picture_bytes).decode('utf-8') if picture_bytes else None

    return jsonify({
        'id': str(dish[0]),
        'title': dish[1],
        'category': dish[2],
        'small_portion': dish[3],
        'medium_portion': dish[4],
        'large_portion': dish[5],
        'small_price': parse_price(dish[6]) if dish[6] else None,
        'medium_price': parse_price(dish[7]) if dish[7] else None,
        'large_price': parse_price(dish[8]) if dish[8] else None,
        'unit': dish[9],
        'description': dish[10],
        'discount_base': float(dish[11]) if dish[11] else None,
        'pic': base64_pic
    }), 200


@app.post("/add_dish")
def add_dish():
    data = request.get_json()
    if not data:
        return jsonify({"message": "Invalid data"}), 400

    token = data.get('token')

    if token is None:
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if user_id is None:
        return {'message': "no session with this user"}, 401

    title = data.get("title")
    category = data.get("category")
    description = data.get("description")
    unit = data.get("portion_unit")
    disc_base = data.get("discount_base")

    small = (data.get("small_portion"), data.get("small_price"))
    medium = (data.get("medium_portion"), data.get("medium_price"))
    large = (data.get("large_portion"), data.get("large_price"))

    image_base64 = data.get("image_base64")
    picture = base64.b64decode(image_base64) if image_base64 else None

    if not add_dish_to_menu(title, category, description, unit, small, medium, large, picture):
        return jsonify({"message": "Something went wrong during adding the dish"}), 500
    else:
        connection.commit()
        return jsonify({"message": "success"}), 200


@app.post("/edit_dish")
def edit_dish():
    try:
        data = request.get_json()
        if not data:
            return jsonify({"message": "Invalid data"}), 400

        # Authentication and validation
        token = data.get('token')
        if not token:
            return jsonify({"message": "Missing token"}), 401

        user_id = get_id(token)
        if user_id is None:
            return jsonify({"message": "Invalid session"}), 401

        dish_id = data.get("id")
        if not dish_id:
            return jsonify({"message": "Missing dish ID"}), 400

        # Process image data
        image_base64 = data.get("image_base64")
        picture = None

        # old_image_base64 = get_from_database("picture", "dish", 'id', dish_id)    //does not work
        cursor.execute("""SELECT picture FROM public.dish WHERE id = %s;""", (dish_id,))
        old_image_base64 = cursor.fetchone()[0]

        if image_base64 and (old_image_base64 != image_base64):
            # Validate and process Base64 image
            # if not image_base64.startswith('data:image/'):
            #     raise ValueError("Invalid image format. Must start with 'data:image/'")

            try:
                header, encoded = image_base64.split(",", 1)
                mime_type = header.split(":")[1].split(";")[0]
                if mime_type not in ['image/jpeg', 'image/png']:
                    raise ValueError("Only JPEG and PNG images are supported")

                picture = base64.b64decode(encoded)
            except Exception as e:
                raise ValueError(f"Invalid image data: {str(e)}")

        # Build dynamic update query
        update_fields = []
        values = []

        # Required fields
        fields = [
            ('title', data.get("title")),
            ('category', data.get("category")),
            ('description', data.get("description")),
            ('portion_unit', data.get("portion_unit")),
            ('discount_base', data.get("discount_base")),
            ('small_portion', data.get("small_portion")),
            ('medium_portion', data.get("medium_portion")),
            ('large_portion', data.get("large_portion")),
            ('small_price', data.get("small_price")),
            ('medium_price', data.get("medium_price")),
            ('large_price', data.get("large_price"))
        ]

        for field, value in fields:
            if value is not None:
                update_fields.append(f"{field} = %s")
                values.append(value)

        # Add picture if provided
        if picture is not None:
            update_fields.append("picture = %s")
            values.append(picture)

        if not update_fields:
            return jsonify({"message": "No fields to update"}), 400

        # Add dish_id to values
        values.append(dish_id)

        # Build and execute query
        update_sql = f"""
            UPDATE dish 
            SET {', '.join(update_fields)}
            WHERE id = %s
            RETURNING *
        """

        cursor.execute(update_sql, values)
        updated_dish = cursor.fetchone()
        connection.commit()

        # Convert picture to Base64 for response
        picture_bytes = updated_dish[12]  # Adjust index based on your schema
        base64_pic = base64.b64encode(picture_bytes).decode('utf-8') if picture_bytes else None

        return jsonify({
            "message": "Dish updated successfully",
            "dish": {
                "id": str(updated_dish[0]),
                "title": updated_dish[1],
                "category": updated_dish[2],
                "small_portion": updated_dish[3],
                "medium_portion": updated_dish[4],
                "large_portion": updated_dish[5],
                "small_price": parse_price(updated_dish[6]) if updated_dish[6] else None,
                "medium_price": parse_price(updated_dish[7]) if updated_dish[7] else None,
                "large_price": parse_price(updated_dish[8]) if updated_dish[8] else None,
                "portion_unit": updated_dish[9],
                "description": updated_dish[10],
                "discount_base": float(updated_dish[11]) if updated_dish[11] else None,
                "pic": base64_pic
            }
        }), 200

    except ValueError as ve:
        return jsonify({"message": str(ve)}), 400
    except Exception as e:
        connection.rollback()
        print(f"Error updating dish: {str(e)}")
        return jsonify({"message": "Internal server error"}), 500


@app.post("/todays_special")
def todays_special():
    data = request.get_json()
    if not data:
        return jsonify({"message": "Invalid data"}), 400

    token = data.get('token')

    if token is None:
        return {'message': "missing token"}, 401

    user_id = get_id(token)
    if user_id is None:
        return {'message': "no session with this user"}, 401

    dish= data.get("special")

    if not dish:
        return jsonify({"error": "No dish provided"}), 400

    if not set_today_special(dish):
        return jsonify({"message": "Something went wrong during setting the dish as special"}), 500
    else:
        return jsonify({"message": "success"}), 200

#--------------sockets
from flask_socketio import SocketIO, emit
from flask_cors import CORS


CORS(app)

socketio = SocketIO(app, cors_allowed_origins="*")
reservations = []

@app.route('/create_reservation', methods=['POST'])
def create_reservation():
    
    data = request.json
    reservations.append(data)
    socketio.emit('reservation_update', data)
    return jsonify({"status": "success"}), 201

@socketio.on('connect')
def handle_connect():
    print("Client connected")

#---------
order1={
    "items": [
        {"name": "vodka", "size": "small", "count": 2},
        {"name": "zemiaky", "size": "medium", "count": 3}
    ]
}
print(find_in_database("dish","title","vodka"))
print(json.dumps(order1))

#app.run(host='147.175.161.105',port=5000)
#app.run(host='192.168.0.101',port=5000)
str_server_address = input("""
\nchoose server address default is 192.168.0.101:5000\n
___address___: port\n""")
if(str_server_address==''):
    str_server_address="192.168.0.101:5000"
str_address, port = str_server_address.split(":")
port=int(port)

import signal
import sys

def handle_exit(sig, frame):
    print("Shutting down...")
    sys.exit(0)

signal.signal(signal.SIGINT, handle_exit)  # Handle Ctrl+C

if __name__ == '__main__':
    socketio.run(app, host=str_address, port=port, debug=True, use_reloader=False)


